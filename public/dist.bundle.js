window.addEventListener("load",(async function(){if(!navigator.gpu)return void alert("WebGPU NOT SUPPORTED\n(could be non-Chrome browser, could be on mobile, or could have no detectable GPU)");const e=await navigator.gpu.requestAdapter();if(!e)return void alert("Couldn't request WebGPU adapter from navigator");const t=await e.requestDevice();if(!t)return void alert("Couldn't get local GPU adapter logical device");const r=document.getElementById("webgpu-target").getContext("webgpu");r.configure({device:t,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"});const o=new Float32Array([0,.6,0,1,1,0,0,1,-.5,-.6,0,1,0,1,0,1,.5,-.6,0,1,0,0,1,1]),a=t.createBuffer({size:o.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(a,0,o,0,o.length);const n=t.createShaderModule({code:"\n    struct VertexOut{\n      @builtin(position) position : vec4f,\n      @location(0) color : vec4f\n    }\n    @vertex\n    fn vertex_main(@location(0) position: vec4f, @location(1) color: vec4f) -> VertexOut{\n      var output : VertexOut;\n      output.position = position;\n      output.color = color;\n      return output;\n    }\n    @fragment\n    fn fragment_main(fragData: VertexOut) -> @location(0) vec4f{\n      return fragData.color;\n    }"}),i={layout:"auto",primitive:{topology:"triangle-list"},vertex:{module:n,entryPoint:"vertex_main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}],arrayStride:32,stepMode:"vertex"}]},fragment:{module:n,entryPoint:"fragment_main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]}},u=t.createRenderPipeline(i),l=t.createCommandEncoder(),c={colorAttachments:[{clearValue:{r:0,g:.5,b:1,a:1},loadOp:"clear",storeOp:"store",view:r.getCurrentTexture().createView()}]},f=l.beginRenderPass(c);f.setPipeline(u),f.setVertexBuffer(0,a),f.draw(3),f.end(),t.queue.submit([l.finish()])}));
//# sourceMappingURL=dist.bundle.js.map